from CYPHER_PROTOCOL.CYPHER_CLIENT.FTP.ftp_client import FTP_CLIENT
import time

# FILE SIZE THAT WILL BE RECIEVED FOR ONE REQUEST
# CHUNK_SIZE CAN BE OF ANY SIZE; JUST KEEP IN MIND :
# "APPROPRIATE TIMEOUT MUST ALSO BE SET TO CLIENT AND SERVER TOO"
# OPTIMUM CHUNK_SIZE DEPENDS ON SYSTEM SPECS; STILL 2MB IS OPTIMUM
# RECV_CHUNK_SIZE AND TRANSMISSION_CHUNK_SIZE MUST BE OF SAME SIZE
RECV_CHUNK_SIZE = 1024*1024*2

# FILE SIZE THAT WILL BE TRANSMITTED FOR ONE REQUEST
# CHUNK_SIZE CAN BE OF ANY SIZE; JUST KEEP IN MIND :
# "APPROPRIATE TIMEOUT MUST ALSO BE SET TO CLIENT AND SERVER TOO"
# OPTIMUM CHUNK_SIZE DEPENDS ON SYSTEM SPECS; STILL 2MB IN OPTIMUM
# RECV_CHUNK_SIZE AND TRANSMISSION_CHUNK_SIZE MUST BE OF SAME SIZE
TRANSMISSION_CHUNK_SIZE = 1024*1024*2

# MAX BYTES THAT WOULD BE RECIEVED IN ONE SINGLE recv() CALL
# MAX LIMIT DEPENDS ON SYSTEM SPECS
RECV_BUFFER = 1024*1024*8

# MAX BYTES THAT WOULD BE TRANSMITTED IN ONE SINGLE send() CALL
# MAX LIMIT OF BYTES DEPENDS ON SYSTEM/PYTHON
TRANSMISSION_BUFFER = 1024*1024*1

# ENCRYPTION_KEY and DECRYPTION_KEY CAN BE SAME OR DIFFERENT                                     
# JUST KEEP IN MIND :                                                                            
# ENCRYPTION_KEY OF SERVER IS DECRYPTION_KEY OF CLIENT                                           
# DECRYPTION_KEY OF SERVER IS ENCRYPTION_KEY OF CLIENT                                           
#                                                                                                
# WE ARE KEEPING BOTH SAME FOR SOME SIMPLICITY
ENCRYPTION_KEY = "2ZpK1CdQfm0s1EZ1SIhYfV7MHdJf8X3U"
DECRYPTION_KEY = "2ZpK1CdQfm0s1EZ1SIhYfV7MHdJf8X3U"

# SERVER TIMEOUT PERIOD; CLIENT IS DISCONNECTED IF
# CLIENT DOES NOT SEND ANY REQUEST IN THIS PERIOD
TIMEOUT = 60*1

# FUNCTION TO LET US KNOW WHEN WE ARE ONLINE
def ONLINE_SIGNAL_PROCESSOR() -> None :
    print("You are online")

# FUNCTION TO LET US KNOW WHEN WE ARE OFFLINE
def OFFLINE_SIGNAL_PROCESSOR() -> None :
    print("You are offline")

# FUNCTION TO LET US KNOW WHAT WE RECIEVED FROM SERVER
def FILE_RESP_HANDLER(responce: dict) -> None :
    print(responce["PATH"])

CLIENT = FTP_CLIENT(
                    file_responce_trigger=FILE_RESP_HANDLER,
                    recv_chunk_size=RECV_CHUNK_SIZE,
                    transmission_chunk_size=TRANSMISSION_CHUNK_SIZE,
                    ip="127.0.0.1", port=12221,
                    encryption_key=ENCRYPTION_KEY,
                    decryption_key=DECRYPTION_KEY,
                    offline_signal_processor=OFFLINE_SIGNAL_PROCESSOR,
                    online_signal_processor=ONLINE_SIGNAL_PROCESSOR,
                    recv_buffer=RECV_BUFFER,
                    transmission_buffer=TRANSMISSION_BUFFER)

if __name__ == "__main__" :
    CLIENT.connect()

    INIT_TIME = time.time()

    print("[@] UPLOADING FILE : DEATHLY_HALLOWS_P1.mkv to MOVIES directory in server")
    # upload_file_s() TAKES TWO ARGUMENTS ONE IS FILE WHICH WE WANT TO UPLOAD;
    # SECOND IS THE PATH IN THE SERVER TO WHICH WE WANT TO UPLOAD THE FILE;
    CLIENT.upload_file_s("DEATHLY_HALLOWS_P1.mkv", "MOVIES")
    print("[#] TIME REQUIRED TO UPLOAD FILE :", time.time()-INIT_TIME)
    INIT_TIME = time.time()

    print("[@] DOWNLOADING FILE : MOVIES/DEATHLY_HALLOWS_P1.mkv to NEWMOVIE/HP in client")
    # fetch_file_s() TAKES THREE ARGUMENTS ONE IS THE PATH OF FILE IN THE SERVER WHICH WE WANT TO FETCH;
    # SECOND IS PATH WHERE WE WANT TO SAVE THE FILE WE ARE FETCHING ON THE CLIENT
    # THIRD IS IF THE USER WANTS TO SAVE THE FILE AUTOMATICALLY OR WANNTS TO SAVE IT MANUALLY :
    # USER CAN GIVE THIRD ARGUMENT AS False IF DESIRES TO SAVE FILE MANUALLY
    CLIENT.fetch_file_s("MOVIES/DEATHLY_HALLOWS_P1.mkv", "NEWMOVIE/HP")
    print("[#] TIME REQUIRED TO DOWNLOAD FILE :", time.time()-INIT_TIME)
